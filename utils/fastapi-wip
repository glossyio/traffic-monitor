from fastapi import FastAPI
import subprocess
import requests
import re
import json

app = FastAPI()

if __name__ == '__main__':
    uvicorn.run(app, host='0.0.0.0', port=8000)

@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/listcams")
async def list_cams(): 
    # Run the command and capture the output
    result = subprocess.run(["rpicam-vid", "--list-cameras"], capture_output=True, text=True)
    
    # Check if the command was successful
    if result.returncode != 0:
        raise RuntimeError(f"Command failed with error: {result.stderr}")
    
    # Initialize the result dictionary
    cameras = {}
    
    # Split the output into lines
    lines = result.stdout.strip().split('\n')
    
    # Regular expressions to match camera information
    camera_pattern = re.compile(r'(\d+) : (\w+) \[(\d+x\d+ \d+-bit)\] \((.*?)\)$')
    mode_pattern = re.compile(r"(?:\s*Modes:\s*'(\w+)' : )?(\d+x\d+) \[(\d+\.\d+ fps) - \((\d+), (\d+)\)/(\d+)x(\d+) crop\]$")
    
    current_camera = None
    
    for line in lines:
        # Match camera information
        camera_match = camera_pattern.match(line)
        if camera_match:
            camera_number = camera_match.group(1)
            camera_name = camera_match.group(2)
            resolution = camera_match.group(3)
            path = camera_match.group(4)
            
            # Initialize camera entry
            cameras[camera_number] = {
                'name': camera_name,
                'resolution': resolution,
                'path': path,
                'modes': []
            }
            current_camera = camera_number
            continue
        
        # Match modes information
        mode_match = mode_pattern.match(line)
        if mode_match and current_camera is not None:
            mode_name = mode_match.group(1)
            mode_resolution = mode_match.group(2)
            fps = mode_match.group(3)
            crop_x1 = mode_match.group(4)
            crop_y1 = mode_match.group(5)
            crop_width = mode_match.group(6)
            crop_height = mode_match.group(7)
            
            # Append mode information to the current camera
            cameras[current_camera]['modes'].append({
                'mode_name': mode_name,
                'resolution': mode_resolution,
                'fps': fps,
                'crop': {
                    'x1': crop_x1,
                    'y1': crop_y1,
                    'width': crop_width,
                    'height': crop_height
                }
            })
    return {cameras}

@app.get("/listgo2rtc")
async def list_go2rtc():
    response = requests.get("http://localhost:1984/api/config")
    output = response.text
    streams = {}
    for line in output.splitlines():
        if line.startswith("streams:"):
            stream_name = line.split(":")[1].strip()
            command = line.split(":")[2].strip()
            streams[stream_name] = {"command": command}
            if "rpicam-vid" in command:
                camera_name = command.split("--camera ")[1].split()[0]
                streams[stream_name]["camera_name"] = camera_name
    return {"streams": streams}

@app.get("/gettime")
async def get_time():
    result = subprocess.run(["date"], capture_output=True, text=True)
    output = result.stdout.strip()
    return {"system_time": output}

@app.post("/settime/{new_time}")
async def set_time(new_time: str):
    """
    Set the system time to a new value.

    Args:
        new_time (str): The new time in ISO 8601 format, e.g. "2023-04-01T12:34:56Z" or current timezone as "2025-04-21 13:34".

    Returns:
        dict: A dictionary containing a message indicating that the system time has been set.
    """
    try:
        subprocess.run(["sudo", "date", "-s", new_time], check=True)
        return {"message": f"System time has been set to {new_time}"}
    except subprocess.CalledProcessError as e:
        return {"error": str(e)}

@app.get("/gettpus")
async def get_tpus():
    """
    Get information about the connected Coral TPU devices.

    Returns:
        dict: A dictionary containing the device name, peripheral information, and if the driver is loaded to `/dev/apex_0`.
    """
    lspci_output = subprocess.run(["lspci", "-nn", "|", "grep", "089a"], capture_output=True, text=True).stdout.strip()
    apex_0_exists = os.path.exists("/dev/apex_0")
    return {"lspci_output": lspci_output, "apex_0_exists": apex_0_exists}
