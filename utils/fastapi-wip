from fastapi import FastAPI
import subprocess
import requests
import re
import json

import datetime
import docker

app = FastAPI()

if __name__ == '__main__':
    uvicorn.run(app, host='0.0.0.0', port=8000)

def initialize_docker_client():
    """
    Initialize the Docker client.
    Returns:
        docker.DockerClient: The initialized Docker client.
    """
    # Use Docker SDK for Python to interact with the Docker daemon
    return docker.from_env()

@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.get("/listsyscams")
async def list_sys_cams(): 
    """
    List Raspberry Pi system cameras.

    Returns:
        dict: A dictionary containing attached cameras and their properties.
    """
    # Run the command and capture the output
    result = subprocess.run(["rpicam-vid", "--list-cameras"], capture_output=True, text=True)
    
    # Check if the command was successful
    if result.returncode != 0:
        raise RuntimeError(f"Command failed with error: {result.stderr}")
    
    # Initialize the result dictionary
    cameras = {}
    
    # Split the output into lines
    lines = result.stdout.strip().split('\n')
    
    # Regular expressions to match camera information
    camera_pattern = re.compile(r'(\d+) : (\w+) \[(\d+x\d+ \d+-bit)\] \((.*?)\)$')
    mode_pattern = re.compile(r"(?:\s*Modes:\s*'(\w+)' : )?(\d+x\d+) \[(\d+\.\d+ fps) - \((\d+), (\d+)\)/(\d+)x(\d+) crop\]$")
    
    current_camera = None
    
    for line in lines:
        # Match camera information
        camera_match = camera_pattern.match(line)
        if camera_match:
            camera_number = camera_match.group(1)
            camera_name = camera_match.group(2)
            resolution = camera_match.group(3)
            path = camera_match.group(4)
            
            # Initialize camera entry
            cameras[camera_number] = {
                'name': camera_name,
                'resolution': resolution,
                'path': path,
                'modes': []
            }
            current_camera = camera_number
            continue
        
        # Match modes information
        mode_match = mode_pattern.match(line)
        if mode_match and current_camera is not None:
            mode_name = mode_match.group(1)
            mode_resolution = mode_match.group(2)
            fps = mode_match.group(3)
            crop_x1 = mode_match.group(4)
            crop_y1 = mode_match.group(5)
            crop_width = mode_match.group(6)
            crop_height = mode_match.group(7)
            
            # Append mode information to the current camera
            cameras[current_camera]['modes'].append({
                'mode_name': mode_name,
                'resolution': mode_resolution,
                'fps': fps,
                'crop': {
                    'x1': crop_x1,
                    'y1': crop_y1,
                    'width': crop_width,
                    'height': crop_height
                }
            })
    return {cameras}

@app.get("/listgo2rtc")
async def list_go2rtc():
    response = requests.get("http://localhost:1984/api/config")
    output = response.text
    streams = {}
    for line in output.splitlines():
        if line.startswith("streams:"):
            stream_name = line.split(":")[1].strip()
            command = line.split(":")[2].strip()
            streams[stream_name] = {"command": command}
            if "rpicam-vid" in command:
                camera_name = command.split("--camera ")[1].split()[0]
                streams[stream_name]["camera_name"] = camera_name
    return {"streams": streams}

@app.get("/gettime")
async def get_time():
    result = subprocess.run(["date"], capture_output=True, text=True)
    output = result.stdout.strip()
    return {"system_time": output}

@app.post("/settime/{new_time}")
async def set_time(new_time: str):
    """
    Set the system time to a new value.

    Args:
        new_time (str): The new time in ISO 8601 format, e.g. "2023-04-01T12:34:56Z" or current timezone as "2025-04-21 13:34".

    Returns:
        dict: A dictionary containing a message indicating that the system time has been set.
    """
    try:
        # Sanitize the input to avoid injection attacks
        sanitized_time = datetime.datetime.fromisoformat(new_time).isoformat()
        subprocess.run(["sudo", "date", "-s", sanitized_time], check=True)
        return {"message": f"System time has been set to {sanitized_time}"}
    except (ValueError, subprocess.CalledProcessError) as e:
        return {"error": str(e)}

@app.get("/gettpus")
async def get_tpus():
    """
    Get information about the connected Coral TPU devices.

    Returns:
        dict: A dictionary containing the device name, peripheral information, and if the driver is loaded to `/dev/apex_0`.
    """
    lspci_output = subprocess.run(["lspci", "-nn", "|", "grep", "089a"], capture_output=True, text=True).stdout.strip()
    apex_0_exists = os.path.exists("/dev/apex_0")
    return {"lspci_output": lspci_output, "apex_0_exists": apex_0_exists}

@app.get("/dockerstatus")
async def get_docker_status():
    """
    Get status of all running Docker containers

    Returns:
        dict: A dictionary containing each Docker container and its status information.
    """
    try:
        # Initialize the Docker client
        client = initialize_docker_client()

        # List all running containers
        containers = client.containers.list()

        # Prepare a dictionary to store container details
        container_details = {}

        for container in containers:
            container_details[container.name] = {
                'id': container.id,
                'image': container.image.tags[0],
                'status': container.status
            }

        return {"containers": container_details}
    except Exception as e:
        return {"error": str(e)}

@app.post("/restartdocker/{container_name}")
async def restart_docker(container_name: str):
    """
    Restart a specified Docker container using the Docker API.

    Args:
        container_name (str): The name of the Docker container to restart.

    Returns:
        dict: A dictionary containing a message indicating that the container has been restarted.
    """
    try:
        client = initialize_docker_client()

        # Find the container by name
        container = client.containers.get(container_name)

        # Restart the container
        container.restart()
        return {"message": f"Docker container '{container_name}' has been restarted."}
    except Exception as e:
        return {"error": str(e)}

# within node-red??
    # TODO get tmdb.sqlite size

    # TODO get latest deployment_id from tmdb.sqlite

    # TODO enable listed/selected camera(s) in node-red config

    # TODO enable listed/selected radar(s) in node-red config

    # TODO Get the latest traffic-monitor repo COMMIT number (do we store this anywhere?)

# with a single call to frigate/config
# TODO grab Frigate config

    # TODO display frigate cameras --> {name} --> enabled, 

    # TODO display frigate detectors --> {name} --> type, 

# TODO display frigate storage size

# TODO display STORAGE total system size and free space (df -h??)

# TODO show system network interface - either wifi or hotspot SSID, connection status

# TODO show journalctl logs (argument for timeframe??)

# TODO system reboot button

# TODO Per Container restart buttons 

# TODO how do I want to handle the WLAN status - pull this out as a separate unit from journalctl

